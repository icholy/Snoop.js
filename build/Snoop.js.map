{"version":3,"sources":["Snoop.js","Snoop.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Snoop","Snoop.register","Snoop.register.snoop","Snoop.fnSignature","arg","trim","Snoop.formatArg","Snoop.formatMsg","Snoop.makeFn","_len","arguments","length","console","log","apply","formatMsg","info","args","undefined","ret","func","this","Snoop.methodInfo","Snoop.enumerateMethods","Snoop.Method","Snoop.Method.constructor","_info","Snoop.Method.on","Snoop.Method.off","module","exports"],"mappings":"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","file":"Snoop.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar Snoop;\n(function (Snoop) {\n    /**\n     * Register an object for snooping\n     *\n     * @param name The object's name\n     * @param object The object\n     * @param allon Turn on snooping on all methods\n     */\n    function register(name, object) {\n        var allon = arguments[2] === undefined ? false : arguments[2];\n\n        if (this.hasOwnProperty(name)) {\n            throw new Error(\"Already snooping on \" + name);\n        }\n        var options = {\n            showReturn: true,\n            showArgNames: true\n        };\n        var methods = enumerateMethods(object);\n        var wrapper = {};\n        function snoop(method) {\n            var info = methodInfo(object, name, method, options);\n            wrapper[method] = new Method(info);\n            if (allon) {\n                wrapper[method].on();\n            }\n        }\n        methods.forEach(snoop);\n        wrapper.snoop = snoop;\n        this[name] = wrapper;\n    }\n    Snoop.register = register;\n\n    var Method = (function () {\n        function Method(info) {\n            _classCallCheck(this, Method);\n\n            this.info = info;\n        }\n\n        _createClass(Method, {\n            on: {\n                /**\n                 * Turn on snooping for this method\n                 */\n\n                value: function on() {\n                    var _info = this.info;\n                    var object = _info.object;\n                    var funcName = _info.funcName;\n\n                    object[funcName] = makeFn(this.info);\n                }\n            },\n            off: {\n                /**\n                 * Turn off snooping for this method\n                 */\n\n                value: function off() {\n                    var _info = this.info;\n                    var object = _info.object;\n                    var funcName = _info.funcName;\n                    var func = _info.func;\n\n                    object[funcName] = func;\n                }\n            }\n        });\n\n        return Method;\n    })();\n\n    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n        FN_ARG_SPLIT = /,/,\n        STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n    /**\n     * Extract a function's parameter names\n     *\n     * @param fn The Function\n     * @return An array of the parameters\n     */\n    function fnSignature(fn) {\n        var fnText = fn.toString().replace(STRIP_COMMENTS, \"\"),\n            args = fnText.match(FN_ARGS);\n        if (!args) {\n            return [];\n        }\n        return args[1].split(FN_ARG_SPLIT).map(function (arg) {\n            return arg.trim();\n        });\n    }\n    /**\n     * Format an argument for printing\n     *\n     * @param arg The argument to format\n     * @return Formatted argument\n     */\n    function formatArg(arg) {\n        if (typeof arg === \"string\") {\n            return \"\\\"\" + arg + \"\\\"\";\n        } else {\n            return arg;\n        }\n    }\n    /**\n     * Format a method invokation for printing\n     *\n     * @param info Context information for the method\n     * @param args Arguments the method was invoked with\n     * @param ret Method return value\n     * @return Message ready to print\n     */\n    function formatMsg(msgType, info, args, ret) {\n        var msg = [msgType + \" - \" + info.objectName + \"#\" + info.funcName + \"(\"],\n            i;\n        for (i = 0; i < args.length; i++) {\n            if (i !== 0) {\n                msg.push(\",\");\n            }\n            if (info.options.showArgNames && info.funcSig[i]) {\n                msg.push(info.funcSig[i] + \" =\");\n            }\n            msg.push(formatArg(args[i]));\n        }\n        msg.push(\")\");\n        if (info.options.showReturn) {\n            msg.push(\"->\");\n            msg.push(formatArg(ret));\n        }\n        return msg;\n    }\n    /**\n     * Make a proxy function that logs invocations\n     *\n     * @param info Context information for the method\n     * @return The proxy function\n     */\n    function makeFn(info) {\n        return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            console.log.apply(console, formatMsg(\"call\", info, args, undefined));\n            var ret = info.func.apply(this, args);\n            console.log.apply(console, formatMsg(\"return\", info, args, ret));\n            return ret;\n        };\n    }\n    /**\n     * Create context information for a method\n     *\n     * @param object Method's parent object\n     * @param objectName parent object's name\n     * @param funcName The method property name\n     * @param options Snoop options\n     * @return Context information for method\n     */\n    function methodInfo(object, objectName, funcName, options) {\n        var func = object[funcName];\n        return {\n            object: object,\n            objectName: objectName,\n            func: func,\n            funcName: funcName,\n            funcSig: fnSignature(func),\n            options: options\n        };\n    }\n    /**\n     * Enumerate methods on an object\n     *\n     * @param object The object to get method names from\n     * @return Array of method names\n     */\n    function enumerateMethods(object) {\n        var methods = [];\n        for (var key in object) {\n            if (Object.prototype.toString.call(object[key]) === \"[object Function]\") {\n                methods.push(key);\n            }\n        }\n        return methods;\n    }\n})(Snoop || (Snoop = {}));\nif (typeof module !== \"undefined\") {\n    module.exports = Snoop;\n}","\nmodule Snoop {\n\n  export interface Options {\n    showReturn:   boolean;\n    showArgNames: boolean;\n  }\n\n  interface MethodInfo {\n    object:     any;\n    objectName: string;\n    func:       Function;\n    funcName:   string;\n    funcSig:    string[];\n    options:    Options;\n  }\n\n  /**\n   * Register an object for snooping\n   *\n   * @param name The object's name\n   * @param object The object\n   * @param allon Turn on snooping on all methods\n   */\n  export function register(name: string, object: any, allon: boolean = false): void {\n    if (this.hasOwnProperty(name)) {\n      throw new Error(`Already snooping on ${name}`);\n    }\n    let options = {\n      showReturn:   true,\n      showArgNames: true\n    };\n    let methods = enumerateMethods(object);\n    let wrapper: any = {};\n    function snoop(method: string) {\n      let info = methodInfo(object, name, method, options);\n      wrapper[method] = new Method(info);\n      if (allon) {\n        wrapper[method].on();\n      }\n    }\n    methods.forEach(snoop);\n    wrapper.snoop = snoop;\n    this[name] = wrapper;\n  }\n\n  class Method {\n\n    constructor(public info: MethodInfo) {}\n\n    /**\n     * Turn on snooping for this method\n     */\n    on(): void {\n      let { object, funcName } = this.info;\n      object[funcName] = makeFn(this.info);\n    }\n\n    /**\n     * Turn off snooping for this method\n     */\n    off(): void {\n      let { object, funcName, func } = this.info;\n      object[funcName] = func;\n    }\n  }\n\n  var FN_ARGS        = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n      FN_ARG_SPLIT   = /,/,\n      STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n \n  /**\n   * Extract a function's parameter names\n   *\n   * @param fn The Function\n   * @return An array of the parameters\n   */\n  function fnSignature(fn: Function): string[] {\n    var fnText = fn.toString().replace(STRIP_COMMENTS, ''),\n        args   = fnText.match(FN_ARGS);\n    if (!args) { return []; }\n    return args[1].split(FN_ARG_SPLIT).map(function (arg) {\n      return arg.trim();\n    });\n  }\n \n  /**\n   * Format an argument for printing\n   *\n   * @param arg The argument to format\n   * @return Formatted argument\n   */\n  function formatArg(arg: any): any {\n    if (typeof arg === 'string') {\n      return '\"' + arg + '\"';\n    } else {\n      return arg;\n    }\n  }\n \n  /**\n   * Format a method invokation for printing\n   *\n   * @param info Context information for the method\n   * @param args Arguments the method was invoked with\n   * @param ret Method return value\n   * @return Message ready to print\n   */\n  function formatMsg(msgType: string, info: MethodInfo, args: any[], ret: any): string[] {\n    var msg = [msgType + ' - ' + info.objectName + '#' + info.funcName + '('],\n        i;\n    for (i = 0; i < args.length; i++) {\n      if (i !== 0) {\n        msg.push(',');\n      }\n      if (info.options.showArgNames && info.funcSig[i]) {\n        msg.push(info.funcSig[i] + ' =');\n      }\n      msg.push(formatArg(args[i]));\n    }\n    msg.push(')')\n    if (info.options.showReturn) {\n      msg.push('->');\n      msg.push(formatArg(ret));\n    }\n    return msg;\n  }\n \n  /**\n   * Make a proxy function that logs invocations\n   *\n   * @param info Context information for the method\n   * @return The proxy function\n   */\n  function makeFn(info: MethodInfo): Function {\n    return function (...args:any[]) {\n      console.log.apply(\n        console,\n        formatMsg('call', info, args, undefined)\n      );\n      let ret = info.func.apply(this, args);\n      console.log.apply(\n        console,\n        formatMsg('return', info, args, ret)\n      );\n      return ret;\n    };\n  }\n\n  /**\n   * Create context information for a method\n   *\n   * @param object Method's parent object\n   * @param objectName parent object's name\n   * @param funcName The method property name\n   * @param options Snoop options\n   * @return Context information for method\n   */\n  function methodInfo(object: any, objectName: string, funcName: string, options: Options): MethodInfo {\n    let func = object[funcName];\n    return {\n      object:     object,\n      objectName: objectName,\n      func:       func,\n      funcName:   funcName,\n      funcSig:    fnSignature(func),\n      options:    options\n    };\n  }\n\n  /**\n   * Enumerate methods on an object\n   *\n   * @param object The object to get method names from\n   * @return Array of method names\n   */\n  function enumerateMethods(object: any): string[] {\n    var methods = [];\n    for (var key in object) {\n      if (Object.prototype.toString.call(object[key]) === '[object Function]') {\n        methods.push(key);\n      }\n    }\n    return methods;\n  }\n\n}\n\ndeclare var module: any;\nif (typeof module !== 'undefined') {\n  module.exports = Snoop;\n}\n\n"],"sourceRoot":"/source/"}