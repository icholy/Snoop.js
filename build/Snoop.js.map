{"version":3,"sources":["Snoop.js","Snoop.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Snoop","Snoop.register","Snoop.fnSignature","arg","trim","Snoop.formatArg","Snoop.formatMsg","Snoop.makeFn","ret","args","Array","slice","call","arguments","info","options","execute","func","apply","this","console","log","formatMsg","Snoop.methodInfo","Snoop.enumerateMethods","Snoop.Method","Snoop.Method.constructor","_info","Snoop.Method.on","Snoop.Method.off"],"mappings":"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","file":"Snoop.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar Snoop;\n(function (Snoop) {\n    Snoop.objects = {};\n    function register(name, object, options) {\n        if (Snoop.objects.hasOwnProperty(name)) {\n            throw new Error(\"Already snooping on \" + name);\n        }\n        var methods = enumerateMethods(Snoop.objects);\n        var wrapper = {};\n        methods.forEach(function (method) {\n            var info = methodInfo(object, name, method, options);\n            wrapper[method] = new Method(info);\n        });\n        Snoop.objects[name] = wrapper;\n    }\n    Snoop.register = register;\n\n    var Method = (function () {\n        function Method(info) {\n            _classCallCheck(this, Method);\n\n            this.info = info;\n        }\n\n        _createClass(Method, {\n            on: {\n                value: function on() {\n                    var _info = this.info;\n                    var object = _info.object;\n                    var funcName = _info.funcName;\n\n                    object[funcName] = makeFn(this.info);\n                }\n            },\n            off: {\n                value: function off() {\n                    var _info = this.info;\n                    var object = _info.object;\n                    var funcName = _info.funcName;\n                    var func = _info.func;\n\n                    object[funcName] = func;\n                }\n            }\n        });\n\n        return Method;\n    })();\n\n    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n        FN_ARG_SPLIT = /,/,\n        STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n    function fnSignature(fn) {\n        var fnText = fn.toString().replace(STRIP_COMMENTS, \"\"),\n            args = fnText.match(FN_ARGS);\n        if (!args) {\n            return [];\n        }\n        return args[1].split(FN_ARG_SPLIT).map(function (arg) {\n            return arg.trim();\n        });\n    }\n    ;\n    function formatArg(arg) {\n        if (typeof arg === \"string\") {\n            return \"\\\"\" + arg + \"\\\"\";\n        } else {\n            return arg;\n        }\n    }\n    function formatMsg(info, args, ret) {\n        var msg = [info.objectName + \"#\" + info.funcName + \"(\"],\n            i;\n        for (i = 0; i < args.length; i++) {\n            if (i !== 0) {\n                msg.push(\",\");\n            }\n            if (info.options.showArgNames && info.funcSig[i]) {\n                msg.push(info.funcSig[i] + \" =\");\n            }\n            msg.push(formatArg(args[i]));\n        }\n        msg.push(\")\");\n        if (info.options.showReturn) {\n            msg.push(\"->\");\n            msg.push(formatArg(ret));\n        }\n        return msg;\n    }\n    function makeFn(info) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments),\n                ret;\n            if (info.options.execute) {\n                ret = info.func.apply(this, args);\n            }\n            console.log.apply(console, formatMsg(info, args, ret));\n            return ret;\n        };\n    }\n    function methodInfo(object, objectName, funcName, options) {\n        var func = object[funcName];\n        return {\n            object: object,\n            objectName: objectName,\n            func: func,\n            funcName: funcName,\n            funcSig: fnSignature(func),\n            options: options\n        };\n    }\n    function enumerateMethods(object) {\n        var methods = [];\n        for (var key in object) {\n            if (Object.prototype.toString.call(object[key]) === \"[object Function]\") {\n                methods.push(key);\n            }\n        }\n        return methods;\n    }\n})(Snoop || (Snoop = {}));","\nmodule Snoop {\n\n  export interface Options {\n    execute:      boolean;\n    showReturn:   boolean;\n    showArgNames: boolean;\n    whitelist:    string[];\n    blacklist:    string[];\n  }\n\n  interface MethodInfo {\n    object:     any;\n    objectName: string;\n    func:       Function;\n    funcName:   string;\n    funcSig:    string[];\n    options:    Options;\n  }\n\n  export var objects = {};\n\n  export function register(name: string, object: any, options: Options): void {\n    if (objects.hasOwnProperty(name)) {\n      throw new Error(`Already snooping on ${name}`);\n    }\n    let methods = enumerateMethods(objects);\n    let wrapper = {};\n    methods.forEach((method: string) => {\n      let info = methodInfo(object, name, method, options);\n      wrapper[method] = new Method(info);\n    });\n    objects[name] = wrapper;\n  }\n\n  class Method {\n\n    constructor(public info: MethodInfo) {}\n\n    on(): void {\n      let { object, funcName } = this.info;\n      object[funcName] = makeFn(this.info);\n    }\n\n    off(): void {\n      let { object, funcName, func } = this.info;\n      object[funcName] = func;\n    }\n  }\n\n  var FN_ARGS        = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n      FN_ARG_SPLIT   = /,/,\n      STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n \n  function fnSignature(fn: Function): string[] {\n    var fnText = fn.toString().replace(STRIP_COMMENTS, ''),\n        args   = fnText.match(FN_ARGS);\n    if (!args) { return []; }\n    return args[1].split(FN_ARG_SPLIT).map(function (arg) {\n      return arg.trim();\n    });\n  };\n \n  function formatArg(arg: any): any {\n    if (typeof arg === 'string') {\n      return '\"' + arg + '\"';\n    } else {\n      return arg;\n    }\n  }\n \n  function formatMsg(info: MethodInfo, args: any[], ret: any): string[] {\n    var msg = [info.objectName + '#' + info.funcName + '('],\n        i;\n    for (i = 0; i < args.length; i++) {\n      if (i !== 0) {\n        msg.push(',');\n      }\n      if (info.options.showArgNames && info.funcSig[i]) {\n        msg.push(info.funcSig[i] + ' =');\n      }\n      msg.push(formatArg(args[i]));\n    }\n    msg.push(')')\n    if (info.options.showReturn) {\n      msg.push('->');\n      msg.push(formatArg(ret));\n    }\n    return msg;\n  }\n \n  function makeFn(info: MethodInfo): Function {\n    return function (/* ... */) {\n      var args = Array.prototype.slice.call(arguments),\n          ret;\n      if (info.options.execute) {\n        ret = info.func.apply(this, args);\n      }\n      console.log.apply(\n        console,\n        formatMsg(info, args, ret)\n      );\n      return ret;\n    };\n  }\n\n  function methodInfo(object: any, objectName: string, funcName: string, options: Options): MethodInfo {\n    let func = object[funcName];\n    return {\n      object:     object,\n      objectName: objectName,\n      func:       func,\n      funcName:   funcName,\n      funcSig:    fnSignature(func),\n      options:    options\n    };\n  }\n\n  function enumerateMethods(object: any): string[] {\n    var methods = [];\n    for (var key in object) {\n      if (Object.prototype.toString.call(object[key]) === '[object Function]') {\n        methods.push(key);\n      }\n    }\n    return methods;\n  }\n\n}\n"],"sourceRoot":"/source/"}