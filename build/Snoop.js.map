{"version":3,"sources":["Snoop.js","Snoop.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Snoop","Snoop.register","Snoop.register.snoop","Snoop.fnSignature","arg","trim","Snoop.formatArg","Snoop.formatMsg","Snoop.makeFn","_len","arguments","length","ret","info","options","execute","func","apply","this","args","console","log","formatMsg","Snoop.methodInfo","Snoop.enumerateMethods","Snoop.Method","Snoop.Method.constructor","_info","Snoop.Method.on","Snoop.Method.off","module","exports"],"mappings":"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","file":"Snoop.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar Snoop;\n(function (Snoop) {\n    function register(name, object) {\n        if (this.hasOwnProperty(name)) {\n            throw new Error(\"Already snooping on \" + name);\n        }\n        var options = {\n            execute: true,\n            showReturn: true,\n            showArgNames: true\n        };\n        var methods = enumerateMethods(object);\n        var wrapper = {};\n        function snoop(method) {\n            var info = methodInfo(object, name, method, options);\n            wrapper[method] = new Method(info);\n        }\n        methods.forEach(snoop);\n        wrapper.snoop = snoop;\n        this[name] = wrapper;\n    }\n    Snoop.register = register;\n\n    var Method = (function () {\n        function Method(info) {\n            _classCallCheck(this, Method);\n\n            this.info = info;\n        }\n\n        _createClass(Method, {\n            on: {\n                value: function on() {\n                    var _info = this.info;\n                    var object = _info.object;\n                    var funcName = _info.funcName;\n\n                    object[funcName] = makeFn(this.info);\n                }\n            },\n            off: {\n                value: function off() {\n                    var _info = this.info;\n                    var object = _info.object;\n                    var funcName = _info.funcName;\n                    var func = _info.func;\n\n                    object[funcName] = func;\n                }\n            }\n        });\n\n        return Method;\n    })();\n\n    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n        FN_ARG_SPLIT = /,/,\n        STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n    function fnSignature(fn) {\n        var fnText = fn.toString().replace(STRIP_COMMENTS, \"\"),\n            args = fnText.match(FN_ARGS);\n        if (!args) {\n            return [];\n        }\n        return args[1].split(FN_ARG_SPLIT).map(function (arg) {\n            return arg.trim();\n        });\n    }\n    ;\n    function formatArg(arg) {\n        if (typeof arg === \"string\") {\n            return \"\\\"\" + arg + \"\\\"\";\n        } else {\n            return arg;\n        }\n    }\n    function formatMsg(info, args, ret) {\n        var msg = [info.objectName + \"#\" + info.funcName + \"(\"],\n            i;\n        for (i = 0; i < args.length; i++) {\n            if (i !== 0) {\n                msg.push(\",\");\n            }\n            if (info.options.showArgNames && info.funcSig[i]) {\n                msg.push(info.funcSig[i] + \" =\");\n            }\n            msg.push(formatArg(args[i]));\n        }\n        msg.push(\")\");\n        if (info.options.showReturn) {\n            msg.push(\"->\");\n            msg.push(formatArg(ret));\n        }\n        return msg;\n    }\n    function makeFn(info) {\n        return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            var ret;\n            if (info.options.execute) {\n                ret = info.func.apply(this, args);\n            }\n            console.log.apply(console, formatMsg(info, args, ret));\n            return ret;\n        };\n    }\n    function methodInfo(object, objectName, funcName, options) {\n        var func = object[funcName];\n        return {\n            object: object,\n            objectName: objectName,\n            func: func,\n            funcName: funcName,\n            funcSig: fnSignature(func),\n            options: options\n        };\n    }\n    function enumerateMethods(object) {\n        var methods = [];\n        for (var key in object) {\n            if (Object.prototype.toString.call(object[key]) === \"[object Function]\") {\n                methods.push(key);\n            }\n        }\n        return methods;\n    }\n    Snoop.enumerateMethods = enumerateMethods;\n})(Snoop || (Snoop = {}));\nif (typeof module !== \"undefined\") {\n    module.exports = Snoop;\n}","\nmodule Snoop {\n\n  export interface Options {\n    execute:      boolean;\n    showReturn:   boolean;\n    showArgNames: boolean;\n  }\n\n  interface MethodInfo {\n    object:     any;\n    objectName: string;\n    func:       Function;\n    funcName:   string;\n    funcSig:    string[];\n    options:    Options;\n  }\n\n  export function register(name: string, object: any): void {\n    if (this.hasOwnProperty(name)) {\n      throw new Error(`Already snooping on ${name}`);\n    }\n    let options = {\n      execute:      true,\n      showReturn:   true,\n      showArgNames: true\n    };\n    let methods = enumerateMethods(object);\n    let wrapper: any = {};\n    function snoop(method: string) {\n      let info = methodInfo(object, name, method, options);\n      wrapper[method] = new Method(info);\n    }\n    methods.forEach(snoop);\n    wrapper.snoop = snoop;\n    this[name] = wrapper;\n  }\n\n  class Method {\n\n    constructor(public info: MethodInfo) {}\n\n    on(): void {\n      let { object, funcName } = this.info;\n      object[funcName] = makeFn(this.info);\n    }\n\n    off(): void {\n      let { object, funcName, func } = this.info;\n      object[funcName] = func;\n    }\n  }\n\n  var FN_ARGS        = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n      FN_ARG_SPLIT   = /,/,\n      STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n \n  function fnSignature(fn: Function): string[] {\n    var fnText = fn.toString().replace(STRIP_COMMENTS, ''),\n        args   = fnText.match(FN_ARGS);\n    if (!args) { return []; }\n    return args[1].split(FN_ARG_SPLIT).map(function (arg) {\n      return arg.trim();\n    });\n  };\n \n  function formatArg(arg: any): any {\n    if (typeof arg === 'string') {\n      return '\"' + arg + '\"';\n    } else {\n      return arg;\n    }\n  }\n \n  function formatMsg(info: MethodInfo, args: any[], ret: any): string[] {\n    var msg = [info.objectName + '#' + info.funcName + '('],\n        i;\n    for (i = 0; i < args.length; i++) {\n      if (i !== 0) {\n        msg.push(',');\n      }\n      if (info.options.showArgNames && info.funcSig[i]) {\n        msg.push(info.funcSig[i] + ' =');\n      }\n      msg.push(formatArg(args[i]));\n    }\n    msg.push(')')\n    if (info.options.showReturn) {\n      msg.push('->');\n      msg.push(formatArg(ret));\n    }\n    return msg;\n  }\n \n  function makeFn(info: MethodInfo): Function {\n    return function (...args:any[]) {\n      var ret;\n      if (info.options.execute) {\n        ret = info.func.apply(this, args);\n      }\n      console.log.apply(\n        console,\n        formatMsg(info, args, ret)\n      );\n      return ret;\n    };\n  }\n\n  function methodInfo(object: any, objectName: string, funcName: string, options: Options): MethodInfo {\n    let func = object[funcName];\n    return {\n      object:     object,\n      objectName: objectName,\n      func:       func,\n      funcName:   funcName,\n      funcSig:    fnSignature(func),\n      options:    options\n    };\n  }\n\n  export function enumerateMethods(object: any): string[] {\n    var methods = [];\n    for (var key in object) {\n      if (Object.prototype.toString.call(object[key]) === '[object Function]') {\n        methods.push(key);\n      }\n    }\n    return methods;\n  }\n\n}\n\ndeclare var module: any;\nif (typeof module !== 'undefined') {\n  module.exports = Snoop;\n}\n\n"],"sourceRoot":"/source/"}